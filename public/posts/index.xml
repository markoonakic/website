<?xml version="1.0" encoding="utf-8"?><rss version="2.0" xml:lang="en-us" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>Marko Nakić</title>
        <link>http://localhost:1313</link>
        <description>Blog posts by Marko Nakić</description>
        <language>en-us</language>
        <lastBuildDate>Mon, 24 Nov 2025 07:50:22 &#43;0100</lastBuildDate>
        <pubDate>Mon, 24 Nov 2025 00:00:00 &#43;0000</pubDate>
        <ttl>60</ttl>
        <atom:link href="http://localhost:1313/posts/index.xml" rel="self" type="application/rss+xml"/>
        <generator>Hugo 0.152.2</generator>
        <managingEditor>marko@markonakic.xyz (Marko Nakić)</managingEditor>
        <webMaster>marko@markonakic.xyz (Marko Nakić)</webMaster>
        <item>
            <title>Talos Linux Installation Guide</title>
            <link>http://localhost:1313/posts/talos-install/</link>
            <guid isPermaLink="true">http://localhost:1313/posts/talos-install/</guid>
            <pubDate>Mon, 24 Nov 2025 00:00:00 &#43;0000</pubDate>
            <author>marko@markonakic.xyz (Marko Nakić)</author><description>What is Talos? Talos Linux is an open‑source Linux distribution built specifically to run Kubernetes. It has a strong focus on security, immutability, and minimalism. It is not meant as a …</description><content:encoded><![CDATA[<h1 id=what-is-talos>What is Talos?</h1><p>Talos Linux is an open‑source Linux distribution built specifically to run Kubernetes.
It has a strong focus on security, immutability, and minimalism. It is not meant as a general‑purpose OS; it exists to be the operating system for Kubernetes nodes and control plane components.​</p><p>This is production grade, secure and hardened Kubernetes.
The OS is immutable and it takes over the whole disk.
There is no SSH access, everything is controlled via API communication using <code>talosctl</code>.
This OS is considered more advanced and abstracts away some things other distributions do not.</p><h1 id=installation>Installation</h1><h2 id=flashing-the-iso>Flashing the ISO</h2><p>First step is going to be flashing the ISO and booting into the installation medium.</p><p>At that point after the OS has booted Talos will be in <strong>maintenance mode</strong>.
While Talos is in maintenance mode it is important to run all <code>talosctl</code> commands with the <code>--insecure</code> flag.
Once we apply the configuration and the OS is installed properly talos will stop accepting the <code>--insecure</code> flag and we will authenticate using the <code>talosconfig</code> file.</p><p>The only thing now is to remember the devices IP address displayed in the dashboard.</p><h2 id=inspecting-the-disks>Inspecting the disks</h2><p>Ensure <code>talosctl</code> is installed on your laptop (and ideally matches the ISO version).</p><p>In a terminal on your laptop (or any other computer on the same network as the Talos machine) we need to run a command that will show us all of the drives of the Talos machine.</p><p>We can do this using a helper variable for convenience:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>NODE_IP=192.168.221.143   # Your talos machine IP here
</span></span></code></pre></div><p>List disks:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>talosctl get disks -n &#34;$NODE_IP&#34; --insecure
</span></span></code></pre></div><h2 id=generate-config-with-the-right-install-disk>Generate config with the right install disk</h2><p>Now once you have listed your disks you will need to select the one you want Talos to be installed to.</p><p>Helper variable for convenience:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>INSTALL_DISK=/dev/sda   # Replace with disk you decided on
</span></span></code></pre></div><p>Generate config:</p><p>Keep in mind this command will generate <code>controlplane.yaml</code>, <code>worker.yaml</code> and <code>talosconfig</code> in your current working directory.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>talosctl gen config CLUSTER_NAME https://$NODE_IP:6443 \
</span></span><span class=line><span class=cl>  --install-disk &#34;$INSTALL_DISK&#34;
</span></span></code></pre></div><p>The <code>--install-disk</code> flag baked the disk you selected into the generated <code>controlplane.yaml</code> and <code>worker.yaml</code>.</p><h2 id=enable-workloads-on-the-control-plane>Enable workloads on the control plane</h2><p><strong>NOTE</strong> - This step is optional, intended for clusters with a low number of nodes.</p><p>Open <code>controlplane.yaml</code> and in the <code>cluster:</code> section add:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>cluster:
</span></span><span class=line><span class=cl>  allowSchedulingOnControlPlanes: true
</span></span></code></pre></div><p>This will allow pods to run on the control-plane node.</p><h2 id=apply-the-config>Apply the config</h2><p>From the directory where  <code>controlplane.yaml</code>  and  <code>talosconfig</code>  were generated, run:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>talosctl apply-config --insecure \
</span></span><span class=line><span class=cl>  --nodes &#34;$NODE_IP&#34; \
</span></span><span class=line><span class=cl>  --file controlplane.yaml
</span></span></code></pre></div><p>The <code>apply-config</code> command sends your config to the ISO-booted node and instructs it to install Talos to the configured disk.</p><h4 id=what-you-should-see-on-the-node>What you should see on the node:</h4><p>Logs of the image being written to the disk you defined in <code>controlplane.yaml</code>.</p><p>At some point the screen will go black and the system will reboot.
Wait until Talos finishes booting and displays the dashboard again.</p><p>Note down the IP to be used as <code>NODE_IP</code> (it may be the same as before, but confirm to be safe).</p><h2 id=point-talosctl-at-this-node-using-talosconfig>Point <code>talosctl</code> at this node using <code>talosconfig</code></h2><p>Now that the node is running from the disk with the keys we generated, stop using <code>--insecure</code> and instead use the <code>talosconfig</code> file that was created using <code>gen config</code>.</p><p>From the same directory, run:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>talosctl --talosconfig=./talosconfig config endpoint &#34;$NODE_IP&#34;
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>talosctl --talosconfig=./talosconfig config node &#34;$NODE_IP&#34;
</span></span></code></pre></div><p>This writes our nodes IP to the <code>endpoint</code> and <code>node</code> values, so that future <code>talosctl</code> calls know where to connect.</p><p>You can check the connectivity by running:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>talosctl --talosconfig=./talosconfig version
</span></span></code></pre></div><p>and</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>talosctl --talosconfig=./talosconfig service kubelet
</span></span></code></pre></div><h2 id=bootstrap-kubernetes>Bootstrap Kubernetes</h2><p>Now we need to bootstrap the Kubernetes control plane (etcd, API server, etcd membership).</p><p>To bootstrap, run:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>talosctl bootstrap \
</span></span><span class=line><span class=cl>  --nodes &#34;$NODE_IP&#34; \
</span></span><span class=line><span class=cl>  --endpoints &#34;$NODE_IP&#34; \
</span></span><span class=line><span class=cl>  --talosconfig=./talosconfig
</span></span></code></pre></div><p>This command is run <strong>once for the whole cluster</strong>, against <strong>one control-plane node</strong>.
Running it multiple times can break etcd.</p><p>It may take a while. If you get some tansient TLS or conection error, just wait 30s and retry as the API finishes starting.</p><h2 id=fetch-kubeconfig-and-verify-the-cluster>Fetch <code>kubeconfig</code> and verify the cluster</h2><p>Once the bootstrap succeeds, grab <code>kubeconfig</code> so you can use <code>kubectl</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>talosctl kubeconfig \
</span></span><span class=line><span class=cl>  --nodes &#34;$NODE_IP&#34; \
</span></span><span class=line><span class=cl>  --endpoints &#34;$NODE_IP&#34; \
</span></span><span class=line><span class=cl>  --talosconfig=./talosconfig \
</span></span><span class=line><span class=cl>  kubeconfig
</span></span></code></pre></div><p>This will write a file called <code>kubeconfig</code> in the current working directory.</p><p>After that:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=k>export</span> <span class=n>KUBECONFIG</span><span class=o>=$</span><span class=n>PWD</span><span class=o>/</span><span class=n>kubeconfig</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>kubectl get nodes
</span></span></code></pre></div><p>After running this you should see your single node in the <code>Ready</code> state, typically with a name derived from your config.</p><p>If you set <code>allowSchedulingOnControlPlanes:true</code>, it will be scheduled for workloads.</p><h4 id=congratilation><strong>Congratilation!!!</strong></h4><p>At this point you should have your Talos cluster up and running!</p><p>If you are currently setting up your homelab, i now recommend you going with a <strong>GitOps</strong> deployment strategy.</p><p>The two main options are <strong>Flux CD</strong> and <strong>Argo CD</strong>.</p><p>For a simple enough homelab i recommend going with <strong>Flux CD</strong> as i will also be creating a guide on setting it up.</p>]]></content:encoded>
            <category>Talos</category>
            <category>Kubernetes</category>
            <category>Homelab</category>
        </item>
        <item>
            <title>Remote decryption using Dropbear SSH</title>
            <link>http://localhost:1313/posts/dropbear-shh/</link>
            <guid isPermaLink="true">http://localhost:1313/posts/dropbear-shh/</guid>
            <pubDate>Mon, 10 Nov 2025 00:00:00 &#43;0000</pubDate>
            <author>marko@markonakic.xyz (Marko Nakić)</author><description>My first encounter with encryption The first time i had encountered encryption was when i was installing Debian on a machine that was meant to be my first homelab. In the disk partitiong segment of …</description><content:encoded><![CDATA[<h2 id=my-first-encounter-with-encryption>My first encounter with encryption</h2><p>The first time i had encountered encryption was when i was installing Debian on a machine that was meant to be my first homelab. In the disk partitiong segment of the installation process I was presented with the option to use LUKS encryption on my drives. Since i had not yet dabbled with the idea, but found it cool, i decided to go with it and encrypt my drives.</p><p>Since i don&rsquo;t keep the homelab machine at my own place, I had to setup remote access to it right away. And in the process i realized - i cannot remotely decrypt my drives if the machine ever powers off. After that i scoured the web for solutions to my problem and in the end i landed on Dropbear SSH.</p><h2 id=what-is-dropbear-shh-and-how-does-it-apply-to-this-use-case>What is Dropbear SHH and how does it apply to this use case</h2><p>Dropbear SSH is a lightweigh SSH server and client that is primarily used on embedded systems with low memory and processor resources.</p><p>Most systems have some sort of pre-boot environment. This userspace is loaded into the RAM so that the kernel can load drivers and logic that&rsquo;s needed to mount the real root filesystem. The Linux kernel is shipped with the initramfs filesystem (or equivalent) by default.</p><p>Dropbear SHH can be leveraged to gain access to this pre-boot filesystem before the drives are mounted. This allows us to remotely decrypt the drives of our machine.</p><h2 id=implementation>Implementation</h2><p><strong>NOTE</strong> - This implementation walkthrough will be for Debian and Debian based systems, but the same principles still apply to others.</p><h3 id=update-and-upgrade-your-machine>Update and upgrade your machine</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>sudo apt update
</span></span><span class=line><span class=cl>sudo apt upgrade
</span></span></code></pre></div><h3 id=install-dropbear>Install Dropbear</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>sudo apt install dropbear-initramfs
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl> sudo -i
</span></span><span class=line><span class=cl> cd /etc/dropbear/initramfs/
</span></span></code></pre></div><p>Because these files affect the boot image, they live under /etc. Using <code>sudo -i</code> we can get a clean root environment that behaves as if we physically logged in as root.</p><h3 id=configure-dropbearconf>Configure dropbear.conf</h3><p>Options:</p><ul><li><code>-I</code> : Disconnect the session if no traffic is transmitted or received in x seconds</li></ul><p>Auto-disconnecting inactive sessions reduces exposure in the early boot process.</p><ul><li><p><code>-j</code>: Disable ssh local port forwarding.</p></li><li><p><code>-k</code> : Disable remote port forwarding.</p></li></ul><p>Disabling port forwarding minimizes attack surface.</p><ul><li><code>-p</code> : Dropbear listen on this specified TCP port.</li></ul><p>I always use a non default port to avoid generic scaning noise.</p><ul><li><code>-s</code> : Disable password logins.</li></ul><p>Always disable password logins and use key pairs for authentication.</p><p>Example:</p><pre><code>DROPBEAR_OPTIONS=&quot;-I 239 -j -k -p 5768 -s&quot;
</code></pre><h3 id=set-early-boot-networking>Set early-boot networking</h3><p>Early boot networking needs to be set in order for Dropbear to accept SSH before userspace networking is up. This is done by injecting a static IPv4 configuration in the initramfs config file => /etc/initramfs-tools/initramfs.conf.</p><p>Format:</p><pre><code>IP=SERVER_IP::ROUTER_IP:NETMASK:SERVER_HOSTNAME
</code></pre><p>Example:</p><pre><code>IP=192.168.1.36::192.168.1.1:255.255.255.0:node2
</code></pre><h3 id=update-the-initramfs>Update the initramfs</h3><pre><code>sudo update-initramfs -u -v
</code></pre><p>This rebuilds the initramfs with the changes for the current kernel. This command must be run after every change to the initramfs config so that it takes affect at boot.</p><h3 id=create-the-keys>Create the keys</h3><h4 id=generate-a-new-client-key>Generate a new client key</h4><pre><code>ssh-keygen -t rsa -f ~/.ssh/dropbear
</code></pre><p>The <code>-t</code> flag specifies what type of key to generate, while the <code>-f</code> flag specifies the file name and path.</p><h4 id=copy-the-key-to-the-server>Copy the key to the server:</h4><pre><code>scp ~/.ssh/dropbear.pub marko@192.168.0.200:~/dropbear.pub
</code></pre><p>Using scp we can copy the public key to the remote system of SSH.</p><h4 id=add-the-key-to-the-initramfs-authorized-keys>Add the key to the initramfs authorized keys:</h4><pre><code>cat /home/marko/dropbear.pub &gt;&gt; /etc/dropbear/initramfs/authorized_keys
</code></pre><p>The key needs to be present in the initramfs so the authentication can succeed during the pre-boot process.</p><h4 id=stop-being-root>Stop being root</h4><pre><code>exit
</code></pre><h4 id=update-initramfs-again>Update initramfs again</h4><pre><code>sudo update-initramfs -u
</code></pre><h3 id=making-an-alias-optional>Making an alias (optional)</h3><h4 id=edit-the-bashrc-on-the-client>Edit the bashrc on the client</h4><pre><code>vim ~/.bashrc
</code></pre><p>I suggest making an alias for ease of use.</p><h4 id=add-the-alias>Add the alias</h4><p>Format:</p><pre><code>alias &lt;Aliasname&gt;=&quot;ssh -i ~/.ssh/dropbear -p &lt;port&gt; -o 'HostKeyAlgorithms ssh-rsa' root@&lt;SERVER_IP&gt; 'echo -n &lt;DRIVE_ENCRYPTION_PASSWORD&gt; | cryptroot-unlock'&quot;
</code></pre><ul><li><code>-i</code> flag selects the private key we created</li><li><code>-p</code> flag specifies the dropbear port</li><li><code>-o</code> flag forces the use of the RSA algorithm with witch we crated the key pair</li><li><code>root@</code> ensures we connect as a root user to the server</li><li>The <code>echo</code> command is for ease of use and is optional, if not included you will have to provide the password manually to unlock</li></ul><p>Exemple:</p><pre><code>alias unlock=&quot;ssh -i ~/.ssh/dropbear -p 5768 -o 'HostKeyAlgorithms ssh-rsa' root@192.168.0.200 'echo -n test | cryptroot-unlock'&quot;
</code></pre><h4 id=source-the-bashrc>Source the bashrc:</h4><pre><code>source .bashrc
</code></pre><p>This reloads the shell configuration so the alias is available immediately.</p><h3 id=reboot>Reboot:</h3><pre><code>sudo reboot now
</code></pre><p>Time to reboot the machine and test it out!</p><h2 id=try-to-unlock-the-server-with-your-alias>Try to unlock the server with your alias:</h2><pre><code>unlock
</code></pre><h2 id=manual-unlock-with-no-alias>Manual unlock with no alias:</h2><pre><code>ssh -i ~/.ssh/dropbear -p &lt;port&gt; -o &quot;HostKeyAlgorithms ssh-rsa&quot; root@&lt;SERVER_IP&gt;
cryptroot-unlock
</code></pre>]]></content:encoded>
            <category>Linux</category>
            <category>Encryption</category>
            <category>Remote Access</category>
        </item>
    </channel>
</rss>
